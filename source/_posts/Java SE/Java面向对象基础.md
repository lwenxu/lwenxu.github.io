---
title: Java面向对象基础
date: 2017-08-09 10:27:50
tags: 面向对象
categories:
  -Java
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面向对象一直是一种很流行的思想，他的精髓也就在于他的三大特性：封装，继承和多态。本文就在这三个方面简单的谈一谈Java的面向对象基础。
### 1.封装：
&nbsp;&nbsp;&nbsp;&nbsp;封装顾名思义，就是将一些对象的属性和方法隐藏于本类之中，其他的类无法访问本类的这些被封装的属性和方法。也就是这些方法和属性仅仅是为了本类服务的。  
除了为本类服务之外封装还可以只暴露自己想给别人提供的服务，而对于一些特殊的底层的服务不希望别人能看到，或者调用。  
<!--more-->
总的来说封装有以下作用或者好处：  
1. 为本类提供服务  
2. 对外暴露部分接口
3. 屏蔽类底层的实现细节
4. 防止别人破坏类内部的核心结构，例如直接继承，然后覆盖核心方法，或者装饰者模式，造成违背作则意愿的修改。

### 2.继承：
&nbsp;&nbsp;&nbsp;&nbsp;继承这个名词也很形象，就是子类去获得父类的共有的或者保护的属性以及方法，然后再次基础上进行扩充进一步完善类代码和功能。继承一把来说在直观上是为我们节省了代码量，父类中已有的方法和属性我们无需再次书写，但是继承并非为了节省代码量而被提出的，而是因为他展示了类与类之间的联系。一般两个类有间接或直接的关系我们才会去继承，而不是单单为了节省代码量。
#### 1.他的主要功能：  
1. 展现类之间的关系
2. 节省代码量
3. 提高了代码的重用性
4. 因为有了继承才有的多态

#### 2.另外还有一些需要注意的地方：  
&nbsp;&nbsp;&nbsp;&nbsp;java只支持单继承，不支持多继承，多继承会导致功能紊乱
&nbsp;&nbsp;&nbsp;&nbsp;例如多个父类中有相同的方法，但是同时继承就会产生不知道继承哪一个方法的问题
但是java还是保留了C++的这种多继承的机制，叫做多实现，也就是在接口上支持多继承( 实现 )。  
&nbsp;&nbsp;&nbsp;&nbsp;但是继承的时候要注意他们是is a的关系也就是每一个子类对象都是一个父类对象。  子类对象 is a  一个父类对象。

#### 3.继承中的 super 和 this
##### 1.super指针指向的就是父类的对象

1. 变量：
如果子类中出现了父类中的非私有的同名变量
要访问子类中变量直接this或者不写，要访问父类中的变量使用super

2. 函数：
覆盖：保留父类的方法的功能定义，重写功能内容；
子类的覆盖的函数权限必须大于父类的函数的权限，对于没有权限限定的就是默认权限，他是介于公有与私有之间的一种权限
子类中只能使用静态方法覆盖静态方法

注意：
1. 重写：他们的参数列表与返回值都必须一样
2. 重载：他们的参数列表一定不一样，返回值无所谓

##### 2. this 代表的是所在函数所属对象
简单来说就是this在哪个函数，这个函数是哪个对象的，this指的就是哪个对象
但是注意，this他并不是当前对象而是指向当前对象，他类似于一个指针
this的应用：
1. 就是当前对象的方法需要引用当前对象的时候我们才使用this  
2. this的第二个应用就是，在构造函数中使用类似于函数的方式来调用该类中的其他构造函数，注意他也只能出现在构造函数的互相调用之中
```Java
class PersonDemo2{
    private int age;
    private String name;

    private PersonDemo2(){
        System.out.println("no params ");
    }

    private PersonDemo2(String name){
        this();
        this.name=name;
    }

    PersonDemo2(String name,int age){
        this(name);
        this.age=age;
    }
}
```
this在构造函数中的互相调用不允许一直互相反复调用会造成死循环
### 3.多态：
&nbsp;&nbsp;&nbsp;&nbsp;多态算是面向对象里面比较复杂的一个功能也是一个极其好用的功能。一句话来概括多态的话可以说，" 一个接口，多个实现 "。就是同一种事物表现出的多种形态。  
&nbsp;&nbsp;&nbsp;&nbsp;多态允许将子类的对象当作父类的对象使用，某父类型的引用指向其子类型的对象,调用的方法是该子类型的方法。这里引用和调用方法的代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定。  
#### 1.他的具体体现就是：  
1. 父类的引用指向子类的对象
2. 父类的引用可以接受子类的对象作为参数

&nbsp;&nbsp;&nbsp;&nbsp;这里父类的引用指向了子类的实例，那么这里会发生一个自动的向上类型转换，就是自动的把子类的对象提升为父类的对象，但是这样会造成精度的损失，也就是子类的特性被销毁了子类独有的方法和属性无法再调用了。  
&nbsp;&nbsp;&nbsp;&nbsp;但是既然可以向上类型转换必然就存在向下类型转换，也就是把父类对象转为子类对象。只不过这种转换仅仅可以出现在父类对象是因为向上类型转换的对象，而不能平白无故的把一个父类对象，转为子类对象。
#### 2.多态的前提：
1. 必须要有继承或者接口的实现
2. 必须存在方法的覆盖  

#### 3.参数的动态绑定：
###### 1.在多态中（也就是在父类的引用指向子类的时候）对成员函数来说：
1. 在编译期间：看引用的成员函数，是否存在如果不存在编译不通过。（编译期间就是看的是类型的声明，声明里有就编译通过没有就失败）
2. 在运行期间：看实际对象的函数，运行实际的对象的方法。（运行使用的是对象运行里面的this指的就是new 哪个类方法就被绑定在哪个对象上）  

&nbsp;&nbsp;&nbsp;&nbsp;简单来说就是编译看右边，运行看左边（儿子充当父亲，人家编译的时候看的你是一个父亲那么就看你父亲是不是有这个方法，而运行的时候儿子会做什么就做什么而不是按照父亲的做），总之一句话：“ 编译声明检查，运行动态绑定 ”


###### 2.再多态中，成员变量的特点：
&nbsp;&nbsp;&nbsp;&nbsp;变量始终与引用类型看齐（向左看齐）无论是静态变量还是非静态  静态就好说与类绑定自然就看引用  说白了成员变量没有方法那种动态绑定

###### 3.静态方法：
&nbsp;&nbsp;&nbsp;&nbsp;始终与引用类型看齐  因为是静态绑定  静态方法与类绑定
