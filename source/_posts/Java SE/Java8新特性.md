---
title: Java8新特性
date: 2017-08-19 10:49:28
tags: Java8
categories:
 -Java
---

### 1.HashMap
首先就是对 java 的 HashMap 进行了修改，以前是通过 hashCode 方法来判断他们的地址值是否一样
，如果相同的话再使用 equals 方法比对他们的 equals 返回的结果是否一样，是则不存入否则的话就形成一个链表
直接挂在原有元素的后面。这个地方就有一个比较大的问题就是使用 hashCode 方法的时候组字坏的情况时需要和每一个元素
比对 hashCode 比较的次数就变多了。 这里后来提出了一种解决方案，就相当于一个数组，然后数组的元素就是一个 entry<!--more-->
这样的话 hashCode 值只需要成为数组的下标即可，可以直接取出数据，然后再调用 equals 方法，这里还需要注意的是，这个数组
一开始是 16 个，但是当容量达到总容量的 75% 的时候就进行扩容，而不可以等到 100% 原因就是防止有一些元素始终在某个位置插入
而其他的位置始终为空。这就是新特性对于 hashCode 方法这一块的优化方案。然后对于后面的 equals 方法形成的链表，java8也进行
了优化，具体就是当元素的总个数超过 64 链表的长度超过 8 的时候把链表元素形成红黑树，红黑树也是二叉树的一种，可以简单的理解为
若元素大于根元素放左边小于放右边。这样以来再链表查询的时候就可以快速定位。

### 2.CurrentHashMap
这里使用了 CAS 算法，从而实现了无锁添加元素，因为 CAS 算法是受底层的操作系统的支持的，所以效率很高。

### 3.永久区 PremGen
以前堆内存中是有一块内存称之为永久区，这个区主要存放的就是类的加载信息，尤其是核心类库。但是这个区一般很少被垃圾回收机制所回收。在 java8 中彻底的把这个区去掉了，二天了一个元空间区 Matespace 他是用的物理内存，而不是从系统申请来的。

### 4.Lambda 表达式
java8 中的 Lambda 表达式就是一种语法糖，简化书写用的。例如我们需要对一个员工集合里面的元素进行筛选，筛选出工资大于 5000 的员工，然后我们还需要筛选出年龄小于 50 的员工，这样的话我们就会发现这两个函数功能虽然不一样其实很多东西就是重复的，这里可以使用一个设计模式就是策略设计模式，这个设计模式主要的实现方式就是定义一个接口，然后只用写一个方法，在这个方法的参数列表中使用这个接口，使用这个接口的方法来处理我们的需求。类似于所说的回调函数。当我们调用方法的时候我们需要传入这个接口的实际对象，这时候这根 函数就会因为我们传入的对象不同从而执行不同的方法。
这个需要传入的对象，我们可以使用匿名内部类来实现，这个时候我们发现这个匿名内部类最重要的就是实现的接口的那个函数的方法体。我们这里就是可使用 Lambda 表达式来代替匿名内部类。

### 5. Lambda 表达式的语法
Lambda 表达式的语法很简单，左侧就是需要实现接口的函数的参数，然后这个东西当参数只有一个的时候圆括号可以不写，然后这里面的参数都不用带类型，当然带上也没问题，主要是 java8 的新特新中有一个就是类型推断，例如说在写泛型的时候 new 对象的时候我们并没有写泛型的名称。而是 java 自动推断出来的。
其右侧就是正宗的方法体，这个方法体如果有多行代码的时候呢我们需要时使用大括号包含起来。
否则就可以直接是用一行代码即可。当只有一行代码的时候我们返回值的 return 语句都可以不用写，直接写表达式即可。
但是注意这个地方我们的 Lambda 表达式只实现了接口中的一个方法，那如果接口中有多个方法，表达式就不知道需要实现哪一个，所以这里就有一个约定就是接口必须是函数式接口，所谓函数是借口就是接口中只有一个函数，然后我们可以使用 @FunctionalInterface 这个注解来声明他就是一个函数式接口。

### 6. 四大核心接口
#### 1. Consumer 消费接口
  传一个参数没有返回值
  T accept(T t)
#### 2. Supplier 供给接口
  不传参数，返回一个东西
  T get()
#### 3. Funtion  函数接口
  传进去一个T，返回一个M
  M apply(T t)
#### 4. Pridecate 断言接口
  boolean test(T t)
